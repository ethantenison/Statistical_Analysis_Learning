x <- model.frame(reg)[,2]
bs.reg <- lm(y.star~x)
# Create bootstrapped adjusted residuals
bs.lev <- influence(bs.reg)$hat
bs.s   <- residuals(bs.reg)/sqrt(1-bs.lev)
bs.s   <- bs.s - mean(bs.s)
# Calculate draw on prediction error
xb.xb <- coef(my.reg)["(Intercept)"] - coef(bs.reg)["(Intercept)"]
xb.xb <- xb.xb + (coef(my.reg)["x"] - coef(bs.reg)["x"])*x_Np1
return(unname(xb.xb + sample(bs.s,size=1)))
}
# Do bootstrap with 10,000 replications
ep.draws <- replicate(n=10000,the.replication(reg=my.reg,s=my.s.resid,x_Np1=78))
# Create prediction interval
y.p+quantile(ep.draws,probs=c(0.05,0.95))
# prediction interval using normal assumption
predict(my.reg,newdata=data.frame(x=78),interval="prediction",level=0.90)
# Quick and dirty Monte Carlo to see which prediction interval is better
# That is, what are the 5th and 95th percentiles of Y_{N+1}
#
# To do it properly, I guess we would want to do the whole procedure above
# 10,000 times and then see what percentage of the time each prediction
# interval covered Y_{N+1}
y.np1 <- 1 + 78 + (rexp(n=10000,rate=0.25)-4)
quantile(y.np1,probs=c(0.05,0.95))
library(MASS)
library(Hmisc)
my.reg <- lm(y ~ x + poly(x,degree=2), data = df)
# Predict y for x=78:
y.p <- coef(my.reg)["(Intercept)"] + coef(my.reg)["x"]*54.2857143
y.p
# Create adjusted residuals
leverage <- influence(my.reg)$hat
my.s.resid <- residuals(my.reg)/sqrt(1-leverage)
my.s.resid <- my.s.resid - mean(my.s.resid)
reg <- my.reg
s <- my.s.resid
the.replication <- function(reg,s,x_Np1=0){
# Make bootstrap residuals
ep.star <- sample(s,size=length(reg$residuals),replace=TRUE)
# Make bootstrap Y
y.star <- fitted(reg)+ep.star
# Do bootstrap regression
x <- model.frame(reg)[,2]
bs.reg <- lm(y.star~x)
# Create bootstrapped adjusted residuals
bs.lev <- influence(bs.reg)$hat
bs.s   <- residuals(bs.reg)/sqrt(1-bs.lev)
bs.s   <- bs.s - mean(bs.s)
# Calculate draw on prediction error
xb.xb <- coef(my.reg)["(Intercept)"] - coef(bs.reg)["(Intercept)"]
xb.xb <- xb.xb + (coef(my.reg)["x"] - coef(bs.reg)["x"])*x_Np1
return(unname(xb.xb + sample(bs.s,size=1)))
}
# Do bootstrap with 10,000 replications
ep.draws <- replicate(n=10000,the.replication(reg=my.reg,s=my.s.resid,x_Np1=78))
# Create prediction interval
y.p+quantile(ep.draws,probs=c(0.05,0.95))
# prediction interval using normal assumption
predict(my.reg,newdata=data.frame(x=78),interval="prediction",level=0.90)
library(MASS)
library(Hmisc)
my.reg <- lm(y ~ x + poly(x,degree=2), data = df)
# Predict y for x=78:
y.p <- coef(my.reg)["(Intercept)"] + coef(my.reg)["x"]*54.2857143
y.p
# Create adjusted residuals
leverage <- influence(my.reg)$hat
my.s.resid <- residuals(my.reg)/sqrt(1-leverage)
my.s.resid <- my.s.resid - mean(my.s.resid)
reg <- my.reg
s <- my.s.resid
the.replication <- function(reg,s,x_Np1=0){
# Make bootstrap residuals
ep.star <- sample(s,size=length(reg$residuals),replace=TRUE)
# Make bootstrap Y
y.star <- fitted(reg)+ep.star
# Do bootstrap regression
x <- model.frame(reg)[,2]
bs.reg <- lm(y.star~x)
# Create bootstrapped adjusted residuals
bs.lev <- influence(bs.reg)$hat
bs.s   <- residuals(bs.reg)/sqrt(1-bs.lev)
bs.s   <- bs.s - mean(bs.s)
# Calculate draw on prediction error
xb.xb <- coef(my.reg)["(Intercept)"] - coef(bs.reg)["(Intercept)"]
xb.xb <- xb.xb + (coef(my.reg)["x"] - coef(bs.reg)["x"])*x_Np1
return(unname(xb.xb + sample(bs.s,size=1)))
}
# Do bootstrap with 10,000 replications
ep.draws <- replicate(n=10000,the.replication(reg=my.reg,s=my.s.resid,x_Np1=78))
# Create prediction interval
y.p+quantile(ep.draws,probs=c(0.05,0.95))
# prediction interval using normal assumption
predict(my.reg,newdata=data.frame(x=54.2857143),interval="prediction",level=0.90)
library(MASS)
library(Hmisc)
my.reg <- lm(y ~ x + poly(x,degree=2), data = df)
# Predict y for x=78:
y.p <- coef(my.reg)["(Intercept)"] + coef(my.reg)["x"]*54.2857143
y.p
# Create adjusted residuals
leverage <- influence(my.reg)$hat
my.s.resid <- residuals(my.reg)/sqrt(1-leverage)
my.s.resid <- my.s.resid - mean(my.s.resid)
reg <- my.reg
s <- my.s.resid
the.replication <- function(reg,s,x_Np1=0){
# Make bootstrap residuals
ep.star <- sample(s,size=length(reg$residuals),replace=TRUE)
# Make bootstrap Y
y.star <- fitted(reg)+ep.star
# Do bootstrap regression
x <- model.frame(reg)[,2]
bs.reg <- lm(y.star~x)
# Create bootstrapped adjusted residuals
bs.lev <- influence(bs.reg)$hat
bs.s   <- residuals(bs.reg)/sqrt(1-bs.lev)
bs.s   <- bs.s - mean(bs.s)
# Calculate draw on prediction error
xb.xb <- coef(my.reg)["(Intercept)"] - coef(bs.reg)["(Intercept)"]
xb.xb <- xb.xb + (coef(my.reg)["x"] - coef(bs.reg)["x"])*x_Np1
return(unname(xb.xb + sample(bs.s,size=1)))
}
# Do bootstrap with 10,000 replications
ep.draws <- replicate(n=10000,the.replication(reg=my.reg,s=my.s.resid,x_Np1=54.2857143))
# Create prediction interval
y.p+quantile(ep.draws,probs=c(0.05,0.95))
# prediction interval using normal assumption
predict(my.reg,newdata=data.frame(x=54.2857143),interval="prediction",level=0.90)
library(MASS)
library(Hmisc)
my.reg <- lm(y ~ x + poly(x,degree=2), data = df)
# Predict y for x=78:
y.p <- coef(my.reg)["(Intercept)"] + coef(my.reg)["x"]*54.2857143
y.p
# Create adjusted residuals
leverage <- influence(my.reg)$hat
my.s.resid <- residuals(my.reg)/sqrt(1-leverage)
my.s.resid <- my.s.resid - mean(my.s.resid)
reg <- my.reg
s <- my.s.resid
the.replication <- function(reg,s,x_Np1=0){
# Make bootstrap residuals
ep.star <- sample(s,size=length(reg$residuals),replace=TRUE)
# Make bootstrap Y
y.star <- fitted(reg)+ep.star
# Do bootstrap regression
x <- model.frame(reg)[,2]
bs.reg <- lm(y.star~x)
# Create bootstrapped adjusted residuals
bs.lev <- influence(bs.reg)$hat
bs.s   <- residuals(bs.reg)/sqrt(1-bs.lev)
bs.s   <- bs.s - mean(bs.s)
# Calculate draw on prediction error
xb.xb <- coef(my.reg)["(Intercept)"] - coef(bs.reg)["(Intercept)"]
xb.xb <- xb.xb + (coef(my.reg)["x"] - coef(bs.reg)["x"])*x_Np1
return(unname(xb.xb + sample(bs.s,size=1)))
}
# Do bootstrap with 1000 replications
ep.draws <- replicate(n=1000,the.replication(reg=my.reg,s=my.s.resid,x_Np1=54.2857143))
# Create prediction interval
y.p+quantile(ep.draws,probs=c(0.05,0.95))
# prediction interval using normal assumption
predict(my.reg,newdata=data.frame(x=54.2857143),interval="prediction",level=0.90)
library(MASS)
library(Hmisc)
my.reg <- lm(y ~ x + poly(x,degree=2), data = df)
# Predict y for x=78:
y.p <- coef(my.reg)["(Intercept)"] + coef(my.reg)["x"]*54.2857143
y.p
# Create adjusted residuals
leverage <- influence(my.reg)$hat
my.s.resid <- residuals(my.reg)/sqrt(1-leverage)
my.s.resid <- my.s.resid - mean(my.s.resid)
reg <- my.reg
s <- my.s.resid
the.replication <- function(reg,s,x_Np1=0){
# Make bootstrap residuals
ep.star <- sample(s,size=length(reg$residuals),replace=TRUE)
# Make bootstrap Y
y.star <- fitted(reg)+ep.star
# Do bootstrap regression
x <- model.frame(reg)[,2]
bs.reg <- lm(y.star~x)
# Create bootstrapped adjusted residuals
bs.lev <- influence(bs.reg)$hat
bs.s   <- residuals(bs.reg)/sqrt(1-bs.lev)
bs.s   <- bs.s - mean(bs.s)
# Calculate draw on prediction error
xb.xb <- coef(my.reg)["(Intercept)"] - coef(bs.reg)["(Intercept)"]
xb.xb <- xb.xb + (coef(my.reg)["x"] - coef(bs.reg)["x"])*x_Np1
return(unname(xb.xb + sample(bs.s,size=1)))
}
# Do bootstrap with 1000 replications
ep.draws <- replicate(n=10000,the.replication(reg=my.reg,s=my.s.resid,x_Np1=54.2857143))
# Create prediction interval
y.p+quantile(ep.draws,probs=c(0.05,0.95))
# prediction interval using normal assumption
predict(my.reg,newdata=data.frame(x=54.2857143),interval="prediction",level=0.90)
library(MASS)
library(Hmisc)
my.reg <- lm(y ~ x + poly(x,degree=2), data = df)
# Predict y for x=78:
y.p <- coef(my.reg)["(Intercept)"] + coef(my.reg)["x"]*54.2857143
y.p
# Create adjusted residuals
leverage <- influence(my.reg)$hat
my.s.resid <- residuals(my.reg)/sqrt(1-leverage)
my.s.resid <- my.s.resid - mean(my.s.resid)
reg <- my.reg
s <- my.s.resid
the.replication <- function(reg,s,x_Np1=0){
# Make bootstrap residuals
ep.star <- sample(s,size=length(reg$residuals),replace=TRUE)
# Make bootstrap Y
y.star <- fitted(reg)+ep.star
# Do bootstrap regression
x <- model.frame(reg)[,2]
bs.reg <- lm(y.star~x)
# Create bootstrapped adjusted residuals
bs.lev <- influence(bs.reg)$hat
bs.s   <- residuals(bs.reg)/sqrt(1-bs.lev)
bs.s   <- bs.s - mean(bs.s)
# Calculate draw on prediction error
xb.xb <- coef(my.reg)["(Intercept)"] - coef(bs.reg)["(Intercept)"]
xb.xb <- xb.xb + (coef(my.reg)["x"] - coef(bs.reg)["x"])*x_Np1
return(unname(xb.xb + sample(bs.s,size=1)))
}
# Do bootstrap with 1000 replications
ep.draws <- replicate(n=100,the.replication(reg=my.reg,s=my.s.resid,x_Np1=54.2857143))
# Create prediction interval
y.p+quantile(ep.draws,probs=c(0.05,0.95))
# prediction interval using normal assumption
predict(my.reg,newdata=data.frame(x=54.2857143),interval="prediction",level=0.90)
library(MASS)
library(Hmisc)
my.reg <- lm(y ~ x + poly(x,degree=2), data = df)
# Predict y for x=78:
y.p <- coef(my.reg)["(Intercept)"] + coef(my.reg)["x"]*54.2857143
y.p
# Create adjusted residuals
leverage <- influence(my.reg)$hat
my.s.resid <- residuals(my.reg)/sqrt(1-leverage)
my.s.resid <- my.s.resid - mean(my.s.resid)
reg <- my.reg
s <- my.s.resid
the.replication <- function(reg,s,x_Np1=0){
# Make bootstrap residuals
ep.star <- sample(s,size=length(reg$residuals),replace=TRUE)
# Make bootstrap Y
y.star <- fitted(reg)+ep.star
# Do bootstrap regression
x <- model.frame(reg)[,2]
bs.reg <- lm(y.star~x)
# Create bootstrapped adjusted residuals
bs.lev <- influence(bs.reg)$hat
bs.s   <- residuals(bs.reg)/sqrt(1-bs.lev)
bs.s   <- bs.s - mean(bs.s)
# Calculate draw on prediction error
xb.xb <- coef(my.reg)["(Intercept)"] - coef(bs.reg)["(Intercept)"]
xb.xb <- xb.xb + (coef(my.reg)["x"] - coef(bs.reg)["x"])*x_Np1
return(unname(xb.xb + sample(bs.s,size=1)))
}
# Do bootstrap with 1000 replications
ep.draws <- replicate(n=1000,the.replication(reg=my.reg,s=my.s.resid,x_Np1=54.2857143))
# Create prediction interval
y.p+quantile(ep.draws,probs=c(0.05,0.95))
# prediction interval using normal assumption
predict(my.reg,newdata=data.frame(x=54.2857143),interval="prediction",level=0.90)
library(MASS)
library(Hmisc)
my.reg <- lm(y ~ x + poly(x,degree=2), data = df)
# Predict y for x=78:
y.p <- coef(my.reg)["(Intercept)"] + coef(my.reg)["x"]*54.2857143
y.p
# Create adjusted residuals
leverage <- influence(my.reg)$hat
my.s.resid <- residuals(my.reg)/sqrt(1-leverage)
my.s.resid <- my.s.resid - mean(my.s.resid)
reg <- my.reg
s <- my.s.resid
the.replication <- function(reg,s,x_Np1=0){
# Make bootstrap residuals
ep.star <- sample(s,size=length(reg$residuals),replace=TRUE)
# Make bootstrap Y
y.star <- fitted(reg)+ep.star
# Do bootstrap regression
x <- model.frame(reg)[,2]
bs.reg <- lm(y.star~x)
# Create bootstrapped adjusted residuals
bs.lev <- influence(bs.reg)$hat
bs.s   <- residuals(bs.reg)/sqrt(1-bs.lev)
bs.s   <- bs.s - mean(bs.s)
# Calculate draw on prediction error
xb.xb <- coef(my.reg)["(Intercept)"] - coef(bs.reg)["(Intercept)"]
xb.xb <- xb.xb + (coef(my.reg)["x"] - coef(bs.reg)["x"])*x_Np1
return(unname(xb.xb + sample(bs.s,size=1)))
}
# Do bootstrap with 1000 replications
ep.draws <- replicate(n=1000,the.replication(reg=my.reg,s=my.s.resid,x_Np1=54.2857143))
# Create prediction interval
y.p+quantile(ep.draws,probs=c(0.05,0.95))
library(MASS)
library(Hmisc)
my.reg <- lm(y ~ x + poly(x,degree=2), data = df)
# Predict y for x=78:
y.p <- coef(my.reg)["(Intercept)"] + coef(my.reg)["x"]*54.2857143
y.p
# Create adjusted residuals
leverage <- influence(my.reg)$hat
my.s.resid <- residuals(my.reg)/sqrt(1-leverage)
my.s.resid <- my.s.resid - mean(my.s.resid)
reg <- my.reg
s <- my.s.resid
the.replication <- function(reg,s,x_Np1=0){
# Make bootstrap residuals
ep.star <- sample(s,size=length(reg$residuals),replace=TRUE)
# Make bootstrap Y
y.star <- fitted(reg)+ep.star
# Do bootstrap regression
x <- model.frame(reg)[,2]
bs.reg <- lm(y.star~x)
# Create bootstrapped adjusted residuals
bs.lev <- influence(bs.reg)$hat
bs.s   <- residuals(bs.reg)/sqrt(1-bs.lev)
bs.s   <- bs.s - mean(bs.s)
# Calculate draw on prediction error
xb.xb <- coef(my.reg)["(Intercept)"] - coef(bs.reg)["(Intercept)"]
xb.xb <- xb.xb + (coef(my.reg)["x"] - coef(bs.reg)["x"])*x_Np1
return(unname(xb.xb + sample(bs.s,size=1)))
}
# Do bootstrap with 1000 replications
ep.draws <- replicate(n=1000,the.replication(reg=my.reg,s=my.s.resid,x_Np1=54.2857143))
# Create prediction interval
y.p+quantile(ep.draws,probs=c(0.05,0.95))
# prediction interval using normal assumption
predict(my.reg,newdata=data.frame(x=54.2857143),interval="prediction",level=0.90)
library(dplyr)
library(janitor)
library(reshape2)
df <- read.csv("Austin_Water_-_Residential_Water_Consumption.csv")
df <- clean_names(df)
df$year <- substr(df$year_month, 1, 4)
df$year <- as.numeric(df$year)
df$month <- substr(df$year_month, 5, 6)
df$month <- as.factor(df$month)
df <- dplyr::select(df, -c(year_month))
df$customer_class <- gsub(" - ", "_", df$customer_class)
df <- filter(df, postal_code != "")
df$total_gallons[is.na(df$total_gallons)] <- 0
dfwide <- dcast(data=df, postal_code+month+year~customer_class, value.var= 'total_gallons')
dfwide <- clean_names(dfwide)
df$total_gallons[is.na(df$total_gallons)] <- 0
dfwide[is.na(dfwide)] <- 0
library(ggplot2)
options(scipen=999)
print(summary(dfwide))
total_water <- df %>% group_by(year, customer_class) %>%
summarize(total_gallons = sum(total_gallons))
tw <- ggplot(total_water, aes(x=year, y=total_gallons, group=customer_class, color=customer_class)) +
geom_line()
print(tw)
library(caTools)
logdf <- dfwide
for (i in 1:length(logdf$irrigation_residential)){
if(logdf$irrigation_residential[i] > mean(logdf$irrigation_residential)){
logdf$HiResIrr[i] <- 1
}
else if(logdf$irrigation_residential[i] <= mean(logdf$irrigation_residential)){
logdf$HiResIrr[i] <- 0
}
}
set.seed(88)
split = sample.split(logdf$HiResIrr, SplitRatio = 0.75)
logdf <- dplyr::select(logdf, -c(irrigation_residential, postal_code))
train = subset(logdf, split == TRUE)
test = subset(logdf, split == FALSE)
model <- glm(HiResIrr ~.,family=binomial(link='logit'),data=train)
summary(model)
library(ggplot2)
set.seed(666)
x <- rnorm(100, 75, 20)
x2 <- x*x
e <- rnorm(100, 0, 7)
y <- 125 + -3.8*x + 0.035*x**2
df <- data.frame(y, x, x2)
ggplot(data = df, aes(x=x, y=y)) + geom_point() + geom_vline(xintercept = 54.2857143, linetype = "dashed", color = "red")
library(boot)
model <- lm(y ~ x + x2, data = df)
summary(model)
library(boot)
bs <- function(data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(y ~ x + x2, data=d)
return(coef(fit))
return(-coef(fit)["x"]/(2*coef(fit)["x2"]))
}
results <- boot(data=mtcars, statistic=bs,
R=1000)
library(boot)
bs <- function(data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(y ~ x + x2, data=d)
return(coef(fit))
return(-coef(fit)["x"]/(2*coef(fit)["x2"]))
}
results <- boot(data=mtcars, statistic=bs,
R=1000)
results
library(boot)
bs <- function(data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(y ~ x + x2, data=d)
return(-coef(fit)["x"]/(2*coef(fit)["x2"]))
}
results <- boot(data=mtcars, statistic=bs,
R=1000)
results
library(boot)
bs <- function(data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(y ~ x + x2, data=d)
return(-coef(fit)["x"]/(2*coef(fit)["x2"]))
}
results <- boot(data=mtcars, statistic=bs,
R=10)
results
library(boot)
bs <- function(data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(y ~ x + x2, data=d)
return(-coef(fit)["x"]/(2*coef(fit)["x2"]))
}
results <- boot(data=mtcars, statistic=bs,
R=1000)
results
library(boot)
bs <- function(data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(y ~ x + x2, data=d)
return(-coef(fit)["x"]/(2*coef(fit)["x2"]))
}
results <- boot(data=df, statistic=bs,
R=1000)
results
?boot
library(ggplot2)
set.seed(666)
x <- rnorm(100, 75, 20)
x2 <- x*x
e <- rnorm(100, 0, 7)
y <- 125 + -3.8*x + 0.035*x**2
df <- data.frame(y, x, x2)
ggplot(data = df, aes(x=x, y=y)) + geom_point() + geom_vline(xintercept = 54.2857143, linetype = "dashed", color = "red")
library(boot)
model <- lm(y ~ x + x2, data = df)
summary(model)
library(boot)
bs <- function(data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(y ~ x + x2, data=d)
return(-coef(fit)["x"]/(2*coef(fit)["x2"]))
}
results <- boot(data=df, statistic=bs,
R=1000)
results
plot(results, index=2)
plot(results, index=x)
library(boot)
bs <- function(data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(y ~ x + x2, data=d)
return(-coef(fit)["x"]/(2*coef(fit)["x2"]))
}
results <- boot(data=df, statistic=bs(df, 1:100),
R=1000)
library(boot)
bs <- function(data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(y ~ x + x2, data=d)
return(-coef(fit)["x"]/(2*coef(fit)["x2"]))
}
results <- boot(data=df, statistic=bs,
R=1000)
results
bs(data=df, 1:100)
View(results)
View(df)
results <- boot(data=df, statistic=bs,
R=1000)
results
library(boot)
bs <- function(data, indices) {
d <- data[indices,] # allows boot to select sample
fit <- lm(y ~ x + x2, data=d)
return(-coef(fit)["x"]/(2*coef(fit)["x2"]))
}
results <- boot(data=df, statistic=bs,
R=1000)
results
library(boot)
model <- lm(y ~ x + x2, data = df)
summary(model)
library(boot)
model <- lm(y ~ x + x2, data = df)
summary(model)
newdata <- data.frame(x=54.2857143)
predict(model, newdata,interval="prediction")
library(boot)
model <- lm(y ~ x + x2, data = df)
summary(model)
